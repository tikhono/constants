// This file was generated by verifier.rs

pragma circom 2.1.0;
include "./goldilocks_ext.circom";
include "./utils.circom";
include "./poseidon.circom";

template WiresAlgebraMul(l, r) {
  signal input wires[NUM_OPENINGS_WIRES()][2];
  signal output out[2][2];
  out[0] <== GlExtAdd()(GlExtMul()(wires[l], wires[r]), GlExtMul()(GlExtMul()(GlExt(7, 0)(), wires[l + 1]), wires[r + 1]));
  out[1] <== GlExtAdd()(GlExtMul()(wires[l], wires[r + 1]), GlExtMul()(wires[l + 1], wires[r]));
}

template ConstraintPush() {
  signal input constraint[2];
  signal input filter[2];
  signal input value[2];

  signal output out[2];
  out <== GlExtAdd()(constraint, GlExtMul()(value, filter));
}

template EvalGateConstraints() {
  signal input constants[NUM_OPENINGS_CONSTANTS()][2];
  signal input wires[NUM_OPENINGS_WIRES()][2];
  signal input public_input_hash[4];
  signal input constraints[NUM_GATE_CONSTRAINTS()][2];
  signal output out[NUM_GATE_CONSTRAINTS()][2];

  // ConstantGate { num_consts: 2 }
  component c_Constant2 = Constant2();
  c_Constant2.constants <== constants;
  c_Constant2.wires <== wires;
  c_Constant2.public_input_hash <== public_input_hash;
  c_Constant2.constraints <== constraints;

  // PublicInputGate
  component c_PublicInputGateLib = PublicInputGateLib();
  c_PublicInputGateLib.constants <== constants;
  c_PublicInputGateLib.wires <== wires;
  c_PublicInputGateLib.public_input_hash <== public_input_hash;
  c_PublicInputGateLib.constraints <== c_Constant2.out;

  // BaseSumGate { num_limbs: 32 } + Base: 2
  component c_BaseSum32 = BaseSum32();
  c_BaseSum32.constants <== constants;
  c_BaseSum32.wires <== wires;
  c_BaseSum32.public_input_hash <== public_input_hash;
  c_BaseSum32.constraints <== c_PublicInputGateLib.out;

  // BaseSumGate { num_limbs: 63 } + Base: 2
  component c_BaseSum63 = BaseSum63();
  c_BaseSum63.constants <== constants;
  c_BaseSum63.wires <== wires;
  c_BaseSum63.public_input_hash <== public_input_hash;
  c_BaseSum63.constraints <== c_BaseSum32.out;

  // ArithmeticGate { num_ops: 20 }
  component c_Arithmetic20 = Arithmetic20();
  c_Arithmetic20.constants <== constants;
  c_Arithmetic20.wires <== wires;
  c_Arithmetic20.public_input_hash <== public_input_hash;
  c_Arithmetic20.constraints <== c_BaseSum63.out;

  // U32ArithmeticGate { num_ops: 3, _phantom: PhantomData<plonky2_field::goldilocks_field::GoldilocksField> }
  component c_ArithmeticU323 = ArithmeticU323();
  c_ArithmeticU323.constants <== constants;
  c_ArithmeticU323.wires <== wires;
  c_ArithmeticU323.public_input_hash <== public_input_hash;
  c_ArithmeticU323.constraints <== c_Arithmetic20.out;
  out <== c_ArithmeticU323.out;
}
template Constant2() {
  signal input constants[NUM_OPENINGS_CONSTANTS()][2];
  signal input wires[NUM_OPENINGS_WIRES()][2];
  signal input public_input_hash[4];
  signal input constraints[NUM_GATE_CONSTRAINTS()][2];
  signal output out[NUM_GATE_CONSTRAINTS()][2];

  signal filter[2];
  filter <== GlExtMul()(GlExtSub()(GlExt(0, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(2, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(3, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(4, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(5, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(4294967295, 0)(), constants[0]), GlExt(1, 0)()))))));

  for (var i = 0; i < 2; i++) {
    out[i] <== ConstraintPush()(constraints[i], filter, GlExtSub()(constants[2 + i], wires[i]));
  }
  for (var i = 2; i < NUM_GATE_CONSTRAINTS(); i++) {
    out[i] <== constraints[i];
  }
}
template PublicInputGateLib() {
  signal input constants[NUM_OPENINGS_CONSTANTS()][2];
  signal input wires[NUM_OPENINGS_WIRES()][2];
  signal input public_input_hash[4];
  signal input constraints[NUM_GATE_CONSTRAINTS()][2];
  signal output out[NUM_GATE_CONSTRAINTS()][2];

  signal filter[2];
  filter <== GlExtMul()(GlExtSub()(GlExt(0, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(1, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(3, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(4, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(5, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(4294967295, 0)(), constants[0]), GlExt(1, 0)()))))));

  signal hashes[4][2];
  for (var i = 0; i < 4; i++) {
    hashes[i][0] <== public_input_hash[i];
    hashes[i][1] <== 0;
    out[i] <== ConstraintPush()(constraints[i], filter, GlExtSub()(wires[i], hashes[i]));
  }
  for (var i = 4; i < NUM_GATE_CONSTRAINTS(); i++) {
    out[i] <== constraints[i];
  }
}
template BaseSum32() {
  signal input constants[NUM_OPENINGS_CONSTANTS()][2];
  signal input wires[NUM_OPENINGS_WIRES()][2];
  signal input public_input_hash[4];
  signal input constraints[NUM_GATE_CONSTRAINTS()][2];
  signal output out[NUM_GATE_CONSTRAINTS()][2];

  signal filter[2];
  filter <== GlExtMul()(GlExtSub()(GlExt(0, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(1, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(2, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(4, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(5, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(4294967295, 0)(), constants[0]), GlExt(1, 0)()))))));

  component reduce = Reduce(32);
  reduce.alpha <== GlExt(2, 0)();
  reduce.old_eval <== GlExt(0, 0)();
  for (var i = 1; i < 32 + 1; i++) {
    reduce.in[i - 1] <== wires[i];
  }
  out[0] <== ConstraintPush()(constraints[0], filter, GlExtSub()(reduce.out, wires[0]));
  component product[32][2 - 1];
  for (var i = 0; i < 32; i++) {
    for (var j = 0; j < 2 - 1; j++) {
      product[i][j] = GlExtMul();
      if (j == 0) product[i][j].a <== wires[i + 1];
      else product[i][j].a <== product[i][j - 1].out;
      product[i][j].b <== GlExtSub()(wires[i + 1], GlExt(j + 1, 0)());
    }
    out[i + 1] <== ConstraintPush()(constraints[i + 1], filter, product[i][2 - 2].out);
  }
  for (var i = 32 + 1; i < NUM_GATE_CONSTRAINTS(); i++) {
    out[i] <== constraints[i];
  }
}
template BaseSum63() {
  signal input constants[NUM_OPENINGS_CONSTANTS()][2];
  signal input wires[NUM_OPENINGS_WIRES()][2];
  signal input public_input_hash[4];
  signal input constraints[NUM_GATE_CONSTRAINTS()][2];
  signal output out[NUM_GATE_CONSTRAINTS()][2];

  signal filter[2];
  filter <== GlExtMul()(GlExtSub()(GlExt(0, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(1, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(2, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(3, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(5, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(4294967295, 0)(), constants[0]), GlExt(1, 0)()))))));

  component reduce = Reduce(63);
  reduce.alpha <== GlExt(2, 0)();
  reduce.old_eval <== GlExt(0, 0)();
  for (var i = 1; i < 63 + 1; i++) {
    reduce.in[i - 1] <== wires[i];
  }
  out[0] <== ConstraintPush()(constraints[0], filter, GlExtSub()(reduce.out, wires[0]));
  component product[63][2 - 1];
  for (var i = 0; i < 63; i++) {
    for (var j = 0; j < 2 - 1; j++) {
      product[i][j] = GlExtMul();
      if (j == 0) product[i][j].a <== wires[i + 1];
      else product[i][j].a <== product[i][j - 1].out;
      product[i][j].b <== GlExtSub()(wires[i + 1], GlExt(j + 1, 0)());
    }
    out[i + 1] <== ConstraintPush()(constraints[i + 1], filter, product[i][2 - 2].out);
  }
  for (var i = 63 + 1; i < NUM_GATE_CONSTRAINTS(); i++) {
    out[i] <== constraints[i];
  }
}
template Arithmetic20() {
  signal input constants[NUM_OPENINGS_CONSTANTS()][2];
  signal input wires[NUM_OPENINGS_WIRES()][2];
  signal input public_input_hash[4];
  signal input constraints[NUM_GATE_CONSTRAINTS()][2];
  signal output out[NUM_GATE_CONSTRAINTS()][2];

  signal filter[2];
  filter <== GlExtMul()(GlExtSub()(GlExt(0, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(1, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(2, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(3, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(4, 0)(), constants[0]), GlExtMul()(GlExtSub()(GlExt(4294967295, 0)(), constants[0]), GlExt(1, 0)()))))));

  for (var i = 0; i < 20; i++) {
    out[i] <== ConstraintPush()(constraints[i], filter, GlExtSub()(wires[4 * i + 3], GlExtAdd()(GlExtMul()(GlExtMul()(wires[4 * i], wires[4 * i + 1]), constants[2 + 0]), GlExtMul()(wires[4 * i + 2], constants[2 + 1]))));
  }

  for (var i = 20; i < NUM_GATE_CONSTRAINTS(); i++) {
    out[i] <== constraints[i];
  }
}
template ArithmeticU323() {
  signal input constants[NUM_OPENINGS_CONSTANTS()][2];
  signal input wires[NUM_OPENINGS_WIRES()][2];
  signal input public_input_hash[4];
  signal input constraints[NUM_GATE_CONSTRAINTS()][2];
  signal output out[NUM_GATE_CONSTRAINTS()][2];

  signal filter[2];
  filter <== GlExtMul()(GlExtSub()(GlExt(4294967295, 0)(), constants[1]), GlExt(1, 0)());

  for (var i = 0; i < 3; i++) {
    out[i] <== ConstraintPush()(constraints[i], filter, GlExtSub()(wires[4 * i + 3], GlExtAdd()(GlExtMul()(GlExtMul()(wires[4 * i], wires[4 * i + 1]), constants[2 + 0]), GlExtMul()(wires[4 * i + 2], constants[2 + 1]))));
  }

  for (var i = 3; i < NUM_GATE_CONSTRAINTS(); i++) {
    out[i] <== constraints[i];
  }
}
